/* THIS IS EXPERIMENTAL CODE */
/* Currently this is under development by CJS and is not connected to the main STACK codebase */
/* It sits here because the long-term goal is to incorporate it */

/* More general random function - recurses accross the structure.
   Notice the use of the dummy "protect()" function to stop further evaluation.
   E.g.
   rand_recurse((5+protect(2))*x^protect(2)+3*x+7);
   rand_recurse(sin([x,y,z]));
*/
rand_recurse(ex) := block(
    if (integerp(ex) or floatnump(ex) or matrixp(ex) or listp(ex)) then return(rand(ex)),
    if atom(ex) then return(ex),
    if op(ex)=protect then return(first(args(ex))),
    apply(op(ex),maplist(rand_recurse,args(ex)))
    );

/* Truncates a polynomial to only terms of degree "d" or less - always expands out */
poly_truncate(pa,d) := apply("+",maplist(lambda([ex],if hipow(ex,x)>d then 0 else ex), args(expand(pa))));

/****************************************************************/
/*  Inequality functions for STACK                              */
/*                                                              */
/*  Chris Sangwin, <chris@sangwin.com>                          */
/*  V0.1 March 2013                                             */
/*                                                              */
/****************************************************************/


/* Determines if we have a linear inequality in one variable */
linear_inequalityp(ex) := block([ex2],
   if atom(ex) then return(false),
   if not(">"= op(ex) or "<"= op(ex) or ">="= op(ex) or "<="= op(ex)) then return(false),
   ex2:ineqprepare(ex),
   if not(is(length(listofvars(ex2))=1)) then return(false),
   if is(degree(lhs(ex2),first(listofvars(ex2)))=1) then return(true),
   return(false)
)$

/* This removes redundant linear inequalities such as x>1 or x>0 -> x>0 */
ineq_rem_redundant(ex) := block([exl,exn,exg,exl,exo,exv],
  if atom(ex) then return(ex),
  if not(op(ex)="and" or op(ex)="or") then return(ex),
  if op(ex)="and" then exo:[max,min] else exo:[min,max],
  exn:sublist(args(ex),lambda([ex2],not(linear_inequalityp(ex2)))),  
  print(exn),
  exl:sublist(args(ex),linear_inequalityp),
  /* Separate out different variables */
  exv:listofvars(exl),
  exl:maplist(lambda([ex],sublist(exl,lambda([ex2],is(listofvars(ex2)=[ex])))),exv),
  print(exl),
  /* At this point we have linear inequalities, in a single variable, separated out into lists for each individual variable. */
  exl:maplist(lambda([ex],single_linear_ineq_reduce(ex,exo)),exl),
  exl:flatten(exl),
  apply(op(ex),append(exn,exl))
  )$

/* Take a list of linear inequalities the same single variable, and an list of operators, min/max.  
   Returns the equivalent inequalities.
*/
single_linear_ineq_reduce(ex,exo):=block([exg,exl],
  ex:maplist(ineqprepare,ex),
  /* Separate out into x>?, x>=? and x<?, x<=?. */
  exg:sublist(ex,lambda([ex2],is(coeff(lhs(ex2),first(listofvars(ex2)))=1))),
  exl:sublist(ex,lambda([ex2],is(coeff(lhs(ex2),first(listofvars(ex2)))=-1))),
  /* Separate into solution and operator */
  exg:single_linear_ineq_reduce_h(exg,first(exo),true),
  exl:single_linear_ineq_reduce_h(exl,second(exo),false),
  append(exg,exl)
)$

/* Take a list of linear inequalities of the same sign, in a single variable, and an operator, min/max.  
   Return the single equivalent inequality.
*/
single_linear_ineq_reduce_h(exl,exo,odr):=block([m,n,exg],
  if exl=[] then return([]),
  exg:maplist(lambda([ex2],[rhs(first(solve(lhs(ex2)))),op(ex2)]),exl),
  m:apply(exo, maplist(first,exg)),
  n:sublist_indices(exg,lambda([ex2],is(m=first(ex2)))),
  [apply(second(exg[first(n)]), if odr then [first(listofvars(exl)),m] else [m,first(listofvars(exl))])]
)$  

/****************************************************************/
/*  Reporting support functions for STACK                       */
/*                                                              */
/*  Chris Sangwin, <chris@sangwin.com>                          */
/*  V0.1 January 2013                                           */
/*                                                              */
/****************************************************************/

/* Sample ways of representing a PRT in which we might have errors */

/* Evaluate a single node safely. */
node_no(prt,num,inputs) := block([res,err],
    /* Type checking */
    if not(listp(prt)) then (print("STACK exception: node_no expects its first argument to be a list."), return(false)),
    if not(integerp(num)) then (print("STACK exception: node_no expects its second argument to be an integer."), return(false)),
    if is(length(prt)<num) then (print("STACK exception: node_no expects its second argument to less than the length of the first."), return(false)),
    /* Do computation */
    res:errcatch(ev(prt[num],inputs,nouns)),
    if is([] = res) then 
       print(concat("Previous error generated by node number ", string(num), ".")),
    if is([] = res) then
       [] 
    else 
       first(res)
    );

/* Actually traverse the PRT with given inputs                  */
/* Inputs should be in the form of equations such as [ans1=x^2] */
traverse_prt(inputs) := block(
    /* Type checking */
    if not(listp(inputs)) then (print("STACK exception: traverse_prt expects its argument to be a list."), return(false)),
    if not(alllistp(equationp,inputs)) then (print("STACK exception: traverse_prt expects its argument to be a list of equations."), return(false)),
    /* Setup PRT */
    simp:false,
    PRTtests:[
        'ATAlgEquiv(ans1,x^3),
        'ATInt(ans2,[x^3,x]),
        'ATInt(ans2/0,[x^3,x])
    ],
    quiet:[false,false,false],
    nexttrue:[2,3,1],
    nextfalse:[1,1,1],
    /* Creatlist to store previously visited nodes */
    visited:makelist(false, length(PRTtests)),
    current_node:1,
    feedback:[],
    answernote:[],
    /* Actually traverse the tree */
    while not(visited[current_node]) do block([res],
      visited[current_node]:true,
      res:node_no(PRTtests,current_node,inputs),
      if not(listp(res)) then return(false),
      /* Feedback */
      if not(quiet[current_node]) then feedback:cons(res[4], feedback),
      feedback:cons(concat("[STACK-feedback:",string(current_node),"-",string(res[2]),"]"), feedback),
      /* Answernotes */
      if not(is(res[3] = "")) then answernote:cons(res[3], answernote), 
      answernote:cons(concat(string(current_node),"-",string(res[2])), answernote),
      /* Update to next node */
      if res[2] then
          current_node:nexttrue[current_node]
      else
          current_node:nextfalse[current_node]
    ),
    answernote:simplode(reverse(sublist(answernote, lambda([ex],not(is(ex=""))))), " | " ),
    feedback:simplode(reverse(sublist(feedback, lambda([ex],not(is(ex=""))))), " | " ),
    [answernote, feedback]
)$

print("[ STACK-reports started. ]")$
