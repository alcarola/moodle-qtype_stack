/* THIS IS EXPERIMENTAL CODE */
/* Currently this is under development by CJS and is not connected to the main STACK codebase */
/* It sits here because the long-term goal is to incorporate it */

/* More general random function - recurses accross the structure.
   Notice the use of the dummy "protect()" function to stop further evaluation.
   E.g.
   rand_recurse((5+protect(2))*x^protect(2)+3*x+7);
   rand_recurse(sin([x,y,z]));
*/
rand_recurse(ex) := block(
    if (integerp(ex) or floatnump(ex) or matrixp(ex) or listp(ex)) then return(rand(ex)),
    if atom(ex) then return(ex),
    if op(ex)=protect then return(first(args(ex))),
    apply(op(ex),maplist(rand_recurse,args(ex)))
    );

/* Truncates a polynomial to only terms of degree "d" or less - always expands out */
poly_truncate(pa,d) := apply("+",maplist(lambda([ex],if hipow(ex,x)>d then 0 else ex), args(expand(pa))));

/****************************************************************/
/*  Reporting support functions for STACK                       */
/*                                                              */
/*  Chris Sangwin, <chris@sangwin.com>                          */
/*  V0.1 January 2013                                           */
/*                                                              */
/****************************************************************/

/* Sample ways of representing a PRT in which we might have errors */

/* Evaluate a single node safely. */
node_no(prt,num,inputs) := block([res,err],
    /* Type checking */
    if not(listp(prt)) then (print("STACK exception: node_no expects its first argument to be a list."), return(false)),
    if not(integerp(num)) then (print("STACK exception: node_no expects its second argument to be an integer."), return(false)),
    if is(length(prt)<num) then (print("STACK exception: node_no expects its second argument to less than the length of the first."), return(false)),
    /* Do computation */
    res:errcatch(ev(prt[num],inputs,nouns)),
    if is([] = res) then 
       print(concat("Previous error generated by node number ", string(num), ".")),
    if is([] = res) then
       [] 
    else 
       first(res)
    );

/* Actually traverse the PRT with given inputs                  */
/* Inputs should be in the form of equations such as [ans1=x^2] */
traverse_prt(inputs) := block(
    /* Type checking */
    if not(listp(inputs)) then (print("STACK exception: traverse_prt expects its argument to be a list."), return(false)),
    if not(alllistp(equationp,inputs)) then (print("STACK exception: traverse_prt expects its argument to be a list of equations."), return(false)),
    /* Setup PRT */
    simp:false,
    PRTtests:[
        'ATAlgEquiv(ans1,x^3),
        'ATInt(ans2,[x^3,x]),
        'ATInt(ans2/0,[x^3,x])
    ],
    quiet:[false,false,false],
    nexttrue:[2,3,1],
    nextfalse:[1,1,1],
    /* Creatlist to store previously visited nodes */
    visited:makelist(false, length(PRTtests)),
    current_node:1,
    feedback:[],
    answernote:[],
    /* Actually traverse the tree */
    while not(visited[current_node]) do block([res],
      visited[current_node]:true,
      res:node_no(PRTtests,current_node,inputs),
      if not(listp(res)) then return(false),
      /* Feedback */
      if not(quiet[current_node]) then feedback:cons(res[4], feedback),
      feedback:cons(concat("[STACK-feedback:",string(current_node),"-",string(res[2]),"]"), feedback),
      /* Answernotes */
      if not(is(res[3] = "")) then answernote:cons(res[3], answernote), 
      answernote:cons(concat(string(current_node),"-",string(res[2])), answernote),
      /* Update to next node */
      if res[2] then
          current_node:nexttrue[current_node]
      else
          current_node:nextfalse[current_node]
    ),
    answernote:simplode(reverse(sublist(answernote, lambda([ex],not(is(ex=""))))), " | " ),
    feedback:simplode(reverse(sublist(feedback, lambda([ex],not(is(ex=""))))), " | " ),
    [answernote, feedback]
)$

print("[ STACK-reports started. ]")$
